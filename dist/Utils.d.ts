declare type StashOf<T> = {
    [key: string]: T;
};
export declare const REMOVE: unique symbol;
declare type ValueSetter<V> = (v: Readonly<V>) => Readonly<V>;
declare type ValueType<V> = V | ValueSetter<V>;
export declare function freezeImmutableStructures(useFreeze: boolean): void;
export declare function isFrozen(o: any): boolean;
export declare function isDeepFrozen(o: any): boolean;
export declare function replaceImmutable<T, V extends T>(root: Readonly<T>, value: V): Readonly<T & V>;
export declare function replaceImmutable<T>(root: Readonly<T>, path: Array<string | number>, value: any): Readonly<T>;
export declare function replaceImmutable<T, V>(root: Readonly<T>, pathFunc: (root: Readonly<T>) => V, value: ValueType<V>): Readonly<T>;
export declare function replaceImmutable<T, V, A>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A) => V, value: ValueType<V>, arg0: A): Readonly<T>;
export declare function replaceImmutable<T, V, A, B>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A, arg1: B) => V, value: ValueType<V>, arg0: A, arg1: B): Readonly<T>;
export declare function replaceImmutable<T, V, A, B, C>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A, arg1: B, arg2: C) => V, value: ValueType<V>, arg0: A, arg1: B, arg2: C): Readonly<T>;
export declare function updateImmutable<T, V>(root: Readonly<T>, value: Readonly<V>): Readonly<T & V>;
export declare function updateImmutable<T>(root: Readonly<T>, path: Array<string | number>, value: any): Readonly<T>;
export declare function updateImmutable<T, V>(root: Readonly<T>, pathFunc: (root: Readonly<T>) => V, value: ValueType<V>): Readonly<T>;
export declare function updateImmutable<T, V, A>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A) => V, value: ValueType<V>, arg0: A): Readonly<T>;
export declare function updateImmutable<T, V, A, B>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A, arg1: B) => V, value: ValueType<V>, arg0: A, arg1: B): Readonly<T>;
export declare function updateImmutable<T, V, A, B, C>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A, arg1: B, arg2: C) => V, value: ValueType<V>, arg0: A, arg1: B, arg2: C): Readonly<T>;
export declare function deepUpdateImmutable<T, V>(root: Readonly<T>, value: Readonly<V>): Readonly<T & V>;
export declare function deepUpdateImmutable<T>(root: Readonly<T>, path: Array<string | number>, value: any): Readonly<T>;
export declare function deepUpdateImmutable<T, V>(root: Readonly<T>, pathFunc: (root: Readonly<T>) => V, value: ValueType<V>): Readonly<T>;
export declare function deepUpdateImmutable<T, V, A>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A) => V, value: ValueType<V>, arg0: A): Readonly<T>;
export declare function deepUpdateImmutable<T, V, A, B>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A, arg1: B) => V, value: ValueType<V>, arg0: A, arg1: B): Readonly<T>;
export declare function deepUpdateImmutable<T, V, A, B, C>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A, arg1: B, arg2: C) => V, value: ValueType<V>, arg0: A, arg1: B, arg2: C): Readonly<T>;
export declare function applyDiffImmutable<T, V>(root: Readonly<T>, value: Readonly<V>): Readonly<T & V>;
export declare function applyDiffImmutable<T>(root: Readonly<T>, path: Array<string | number>, value: any): Readonly<T>;
export declare function applyDiffImmutable<T, V>(root: Readonly<T>, pathFunc: (root: Readonly<T>) => V, value: ValueType<V>): Readonly<T>;
export declare function applyDiffImmutable<T, V, A>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A) => V, value: ValueType<V>, arg0: A): Readonly<T>;
export declare function applyDiffImmutable<T, V, A, B>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A, arg1: B) => V, value: ValueType<V>, arg0: A, arg1: B): Readonly<T>;
export declare function applyDiffImmutable<T, V, A, B, C>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A, arg1: B, arg2: C) => V, value: ValueType<V>, arg0: A, arg1: B, arg2: C): Readonly<T>;
export declare function deleteImmutable<T>(root: Readonly<T>, path: Array<string | number>): Readonly<T>;
export declare function deleteImmutable<T, V>(root: Readonly<T>, pathFunc: (root: Readonly<T>) => V): Readonly<T>;
export declare function deleteImmutable<T, V, A>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A) => V, arg0: A): Readonly<T>;
export declare function deleteImmutable<T, V, A, B>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A, arg1: B) => V, arg0: A, arg1: B): Readonly<T>;
export declare function deleteImmutable<T, V, A, B, C>(root: Readonly<T>, pathFunc: (root: Readonly<T>, arg0: A, arg1: B, arg2: C) => V, arg0: A, arg1: B, arg2: C): Readonly<T>;
export declare function incrementImmutable<T>(root: Readonly<T>, path: Array<string | number>, value: number): Readonly<T>;
export declare function arrayConcatImmutable<T>(root: Readonly<T>, path: Array<string | number>, values: any[]): Readonly<T>;
export declare function arrayPushImmutable<T>(root: Readonly<T>, path: Array<string | number>, ...values: any[]): Readonly<T>;
export declare function arraySpliceImmutable<T>(root: Readonly<T>, path: Array<string | number>, index: number, deleteCount: number, ...values: any): Readonly<T>;
export declare function cloneImmutable<T>(root: Readonly<T>): Readonly<T>;
export declare function cloneMutable<T>(root: Readonly<T>): T;
export declare function shallowCloneMutable<T>(root: Readonly<T>): T;
export declare function filterImmutable<T>(obj: Readonly<StashOf<T>>, filter: (o: Readonly<T>) => boolean): Readonly<StashOf<T>>;
export declare function filterImmutable<T>(arr: Readonly<T[]>, filter: (o: Readonly<T>) => boolean): Readonly<T[]>;
export declare function mapImmutable<T>(obj: Readonly<StashOf<T>>, callback: (val: Readonly<T>, key: string) => T): Readonly<StashOf<T>>;
export declare function mapImmutable<T>(arr: Readonly<T[]>, callback: (val: Readonly<T>, idx: number) => T): Readonly<T[]>;
export declare function deepFreeze<T>(o: T): Readonly<T>;
export declare function diffImmutable(oNew: any, oOld: any): undefined | any;
export {};

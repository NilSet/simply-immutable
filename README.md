# simply-immutable

ZERO dependencies!
FAST! See the benchmarks.
Minimal object changes on updates.
Type safety for CRUD operations in TypeScript.
Immutable in - immutable out: deep clones incoming objects/arrays for safety.

## cloneImmutable
Deep clone of an object/array. Returns a deeply frozen clone.

## cloneMutable
Deep clone of an object/array. Does not freeze anything in the result, so this is a good way to remove immutability.

## shallowCloneMutable
Shallow clone of an object/array. First level of the result is not frozen.

## replaceImmutable
Replaces object/array fields in the target object/array.
Deep compare on replacing object to minimally change structure.
Creates intermediate objects/arrays as necessary.

## updateImmutable
Merges object/array fields into the target object/array.
Deep compare on updating object fields to minimally change structure.
Creates intermediate objects/arrays as necessary.

## deepUpdateImmutable
Merges object/array fields into the target object/array; merging happens recursively (unlike updateImmutable, which only merges at the first level). Merging after the first level only happens on objects, not arrays.
Deep compare on updating object fields to minimally change structure.
Creates intermediate objects/arrays as necessary.

## deleteImmutable
Removes target field.

## incrementImmutable
Adds to an existing numeric value. If the target value is not a number then it is treated as 0.
`obj = incrementImmutable(obj, ['foo', 'count'], 1);`

## arrayPushImmutable
Adds new values to the end of an array. If the target is not an array then it will be replaced by a new array with only the new values in it.
`obj = arrayPushImmutable(obj, ['foo', 'vals'], 'newVal1', 'newVal2');`

## arrayConcatImmutable
Adds an array of new values to the end of an array. If the target is not an array then it will be replaced by a new array with only the new values in it.
`obj = arrayConcatImmutable(obj, ['foo', 'vals'], ['newVal1', 'newVal2']);`

## arraySpliceImmutable
Works just like Array.splice(). If the target is not an array then it will be replaced by a new array with only the new values in it. This function is much preferable to replaceImmutable for arrays when the change operations are known, because replaceImmutable diffs by array index so a deleted or inserted value will break diffing. arraySpliceImmutable does not have this problem.
`obj = arraySpliceImmutable(obj, ['foo', 'vals'], 3, 1, 'insertedVal');`

## diffImmutable
Given two objects/arrays, generates a diff that can be applied to the second parameter (using applyDiffImmutable) to get the first parameter.

## applyDiffImmutable
Applies a diff generated by diffImmutable. Works almost the same as deepUpdateImmutable, except that nested arrays are also merged.

## filterImmutable
Filters out members of an object/array based on a filter function.

## mapImmutable
Remaps members of an object/array based on a callback function.

## deepFreeze
Recursively freezes an object/array and all children.

## isFrozen
Checks if an object/array is frozen.

## isDeepFrozen
Recursively checks if object/array and all children are frozen.

## freezeImmutableStructures
Enables or disables deep freezing of the outputs of the *Immutable functions.
Enabled by default, but recommended to turn off in production builds (benchmarks have deep freezing turned off).
